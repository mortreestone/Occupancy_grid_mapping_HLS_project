#include "header.h"

struct rb
{
	d_type x;
	d_type y;
	d_type theta;
}rbs;

d_type const xcoords[XDIM]={ -20.00000,-19.500000, -19.000000, -18.500000, -18.000000, -17.500000, -17.000000, -16.500000, -16.000000,
		-15.500000, -15.000000, -14.500000, -14.000000, -13.500000, -13.000000, -12.500000, -12.000000, -11.500000, -11.000000,
		-10.500000, -10.000000, -9.500000, -9.000000, -8.500000, -8.000000, -7.500000, -7.000000, -6.500000, -6.000000, -5.500000,
		-5.000000, -4.500000, -4.000000, -3.500000, -3.000000, -2.500000, -2.000000, -1.500000, -1.000000, -0.500000, 0.000000, 0.500000,
		1.000000, 1.500000, 2.000000, 2.500000, 3.000000, 3.500000, 4.000000, 4.500000, 5.000000, 5.500000, 6.000000, 6.500000,
		7.000000, 7.500000, 8.000000, 8.500000, 9.000000, 9.500000, 10.000000, 10.500000, 11.000000, 11.500000,
		12.000000, 12.500000, 13.000000, 13.500000, 14.000000, 14.500000, 15.000000, 15.500000, 16.000000, 16.500000,
		17.000000,17.500000, 18.000000, 18.500000, 19.000000, 19.500000, 20.000000, 20.500000, 21.000000, 21.500000, 22.000000,
		22.500000, 23.000000, 23.500000, 24.000000, 24.500000, 25.000000, 25.500000, 26.000000, 26.500000, 27.000000, 27.500000,
		28.000000, 28.500000, 29.000000, 29.500000, 30.000000, 30.500000, 31.000000, 31.500000, 32.000000, 32.500000, 33.000000,
		33.500000, 34.000000, 34.500000, 35.000000, 35.500000, 36.000000, 36.500000, 37.000000, 37.500000, 38.000000,
		38.500000,39.000000, 39.500000, 40.000000, 40.500000, 41.000000, 41.500000, 42.000000, 42.500000, 43.000000, 43.500000,
		44.000000, 44.500000, 45.000000, 45.500000, 46.000000, 46.500000, 47.000000, 47.500000, 48.000000, 48.500000, 49.000000, 49.500000};

d_type const ycoords[YDIM]={-30.000000,-29.500000, -29.000000, -28.500000, -28.000000, -27.500000, -27.000000, -26.500000, -26.000000, -25.500000,
		-25.000000, -24.500000, -24.000000, -23.500000, -23.000000, -22.500000, -22.000000, -21.500000, -21.000000, -20.500000, -20.000000,
		-19.500000, -19.000000, -18.500000, -18.000000, -17.500000, -17.000000, -16.500000, -16.000000, -15.500000, -15.000000, -14.500000,
		-14.000000, -13.500000, -13.000000, -12.500000, -12.000000, -11.500000, -11.000000, -10.500000, -10.000000, -9.500000, -9.000000,
		-8.500000, -8.000000, -7.500000, -7.000000, -6.500000, -6.000000, -5.500000, -5.000000, -4.500000, -4.000000, -3.500000, -3.000000,
		-2.500000, -2.000000, -1.500000, -1.000000, -0.500000, 0.000000, 0.500000, 1.000000, 1.500000, 2.000000, 2.500000, 3.000000, 3.500000,
		4.000000, 4.500000, 5.000000, 5.500000, 6.000000, 6.500000, 7.000000, 7.500000, 8.000000, 8.500000, 9.000000, 9.500000, 10.000000,
		10.500000, 11.000000, 11.500000, 12.000000, 12.500000, 13.000000, 13.500000, 14.000000, 14.500000, 15.000000, 15.500000, 16.000000,
		16.500000, 17.000000, 17.500000, 18.000000, 18.500000, 19.000000, 19.500000, 20.000000, 20.500000, 21.000000, 21.500000, 22.000000,
		22.500000, 23.000000, 23.500000, 24.000000, 24.500000, 25.000000, 25.500000, 26.000000, 26.500000, 27.000000, 27.500000, 28.000000,
		28.500000, 29.000000, 29.500000};

void ogm(d_type xi,d_type yi,d_type thetai, d_type angle, d_type z_t,d_type grid[])
{
#pragma HLS INTERFACE s_axilite port=return
    rbs.x=xi;
    rbs.y=yi;
    rbs.theta=thetai;
    find_cells_to_update_for_ray(angle,z_t,grid);
}

void find_cells_to_update_for_ray( d_type z_theta_t, d_type z_t,d_type grid[])
{

    d_type val = PI / 180;
    d_type inv_cx=(z_theta_t+rbs.theta)*val;
    d_type a_x=A*hls::cos(inv_cx);
    //d_type a_y=A*hls::sin(inv_cx);
    d_type a_y;
    d_type a_x2=a_x*a_x;

    // find a_y without using sin function
    int div=inv_cx/(2*PI);
    d_type rm=inv_cx-(div*PI*2);
    a_y=hls::sqrt((A*A)-a_x2);
    if(((PI<rm))|| ((0>rm)&&(rm>(0-PI))))
	{
    a_y=(0-a_y);
	}
    //printf("a_x=%f, a_y=%f \n",a_x,a_y);

    int x;
    int y;
    int xp,yp;
    d_type length=A;
     d_type index[2]={rbs.x,rbs.y};
     int intex[2];
     get_cell_index3(index,intex);
     x=intex[0];
     y=intex[1];
     //printf("x=%f, y=%f before\n",index[0],index[1]);
     //printf("x=%d, y=%d \n",x,y);
     //printf("xccords=%f, yccords=%f\n",xcoords[x],ycoords[y]);
     grid[(y*XDIM)+x]= grid[(y*XDIM)+x]+hls::log10(PFREE/(1-PFREE))+hls::log10(PRIOR/(1-PRIOR));
     xp=intex[0];
     yp=intex[1];

     d_type r;
     d_type x_f;
     d_type y_f;
     d_type l;

     new_loop: while(length< MAX_RANGE)
     {

         index[0]=index[0]+a_x;
         index[1]=index[1]+a_y;
         get_cell_index3(index,intex);
         x=intex[0];
         y=intex[1];
         //printf("x=%f, y=%f before\n",index[0],index[1]);
         //printf("x=%d, y=%d \n",x,y);
         //printf("xccords=%f, yccords=%f\n",xcoords[x],ycoords[y]);
         x_f=xcoords[x]+HALF_RESOLUTION-rbs.x;
         y_f=ycoords[y]+HALF_RESOLUTION-rbs.y;
         r= (x_f*x_f)+(y_f*y_f);
         r=hls::sqrt(r);
         l=(r<(z_t-ALFA))?hls::log10(PFREE/(1-PFREE)):0;
         l=(r>(z_t-ALFA))?hls::log10(POCC/(1-POCC)):l;
         l=(r>(z_t+ALFA))?0:l;
         l=(x==xp && y==yp)?0:l;
         grid[(y*XDIM)+x]=grid[(y*XDIM)+x]+l;
         xp=intex[0];
         yp=intex[1];
         length=length+A;
     }


}


void get_cell_index3(d_type *index, int *intex)
{
    int xi;
    int yi;

//    xi=hls::divide((index[0]-XLIM_F),RESOLUTION)+1;
//    yi=hls::divide((index[1]-YLIM_F),RESOLUTION)+1;

    xi= ((index[0]-XLIM_F)*IN_RESOLUTION);
    yi= ((index[1]-YLIM_F)*IN_RESOLUTION);

    xi=((index[0]>xcoords[xi]))?xi+1:xi;
    yi=((index[1]>ycoords[yi]))?yi+1:yi;

    xi=(xi<1)?0:xi;
    yi=(yi<1)?0:yi;
    xi=(xi>(XDIM-1))?(XDIM-1):xi;
    yi=(yi>(YDIM-1))?(YDIM-1):yi;

    intex[0]=xi;
    intex[1]=yi;
}
